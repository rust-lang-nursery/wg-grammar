Generics = "<" params:GenericParam* %% "," ">";
GenericParam = attrs:OuterAttr* kind:GenericParamKind;
GenericParamKind =
  | Lifetime:{ name:LIFETIME { ":" bounds:LifetimeBound* %% "+" }? }
  | Type:{ name:IDENT { ":" bounds:TypeBound* %% "+" }? { "=" default:Type }? }
  // unstable(const_generics):
  | Const:{ "const" name:IDENT ":" ty:Type }
  ;

ForAllBinder = "for" generics:Generics;

WhereClause = "where" bounds:WhereBound* %% ",";
WhereBound =
  | Lifetime:{ lt:LIFETIME ":" bounds:LifetimeBound* %% "+" }
  | Type:{ binder:ForAllBinder? ty:Type ":" bounds:TypeBound* %% "+" }
  // unstable(#20041):
  | TypeEq:{ binder:ForAllBinder? left:Type { "=" | "==" } right:Type }
  ;

LifetimeBound = outlives:LIFETIME;
TypeBound =
  | Outlives:LIFETIME
  | Trait:TypeTraitBound
  | TraitParen:{ "(" bound:TypeTraitBound ")" }
  ;
TypeTraitBound =
  // unstable(const_trait_bound_opt_out):
  maybe_const:{ "?" "const" }?
  maybe:"?"? binder:ForAllBinder? path:Path;

// Generic args of a path segment.
GenericArgs =
  | AngleBracket:{ "<" args_and_bindings:AngleBracketGenericArgsAndConstraints? ">" }
  | Paren:{ "(" inputs:Type* %% "," ")" { "->" output:Type }? }
  ;

// FIXME(eddyb) find a way to express this `A* B*` pattern better
AngleBracketGenericArgsAndConstraints =
  | Args:GenericArg+ %% ","
  | Constraints:AssocTypeConstraint+ %% ","
  | ArgsAndConstraints:{ args:GenericArg+ % "," "," constraints:AssocTypeConstraint+ %% "," }
  ;

GenericArg =
  | Lifetime:LIFETIME
  | Type:Type
  // unstable(const_generics):
  | Const:{ neg:"-"? lit:LITERAL | "{" expr:Expr "}" }
  ;
AssocTypeConstraint =
  | Eq:{ name:IDENT "=" ty:Type }
  // unstable(associated_type_bounds):
  | Bound:{ name:IDENT ":" bounds:TypeBound* %% "+" };
